using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Zergatul.Cryptography.BlockCipher
{
    // http://210.104.33.10/ARIA/doc/ARIA-specification-e.pdf
    // https://tools.ietf.org/html/rfc5794
    public abstract class ARIA : AbstractBlockCipher
    {
        public override int BlockSize => 16;
        public override int KeySize => Nk / 8;

        private static readonly byte[] S1 = new byte[]
        {
            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
            0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
            0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
            0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
            0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
            0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
            0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
            0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
            0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
            0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
            0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
            0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
            0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
            0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
            0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
            0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
        };

        private static readonly byte[] S2 = new byte[]
        {
            0xE2, 0x4E, 0x54, 0xFC, 0x94, 0xC2, 0x4A, 0xCC, 0x62, 0x0D, 0x6A, 0x46, 0x3C, 0x4D, 0x8B, 0xD1,
            0x5E, 0xFA, 0x64, 0xCB, 0xB4, 0x97, 0xBE, 0x2B, 0xBC, 0x77, 0x2E, 0x03, 0xD3, 0x19, 0x59, 0xC1,
            0x1D, 0x06, 0x41, 0x6B, 0x55, 0xF0, 0x99, 0x69, 0xEA, 0x9C, 0x18, 0xAE, 0x63, 0xDF, 0xE7, 0xBB,
            0x00, 0x73, 0x66, 0xFB, 0x96, 0x4C, 0x85, 0xE4, 0x3A, 0x09, 0x45, 0xAA, 0x0F, 0xEE, 0x10, 0xEB,
            0x2D, 0x7F, 0xF4, 0x29, 0xAC, 0xCF, 0xAD, 0x91, 0x8D, 0x78, 0xC8, 0x95, 0xF9, 0x2F, 0xCE, 0xCD,
            0x08, 0x7A, 0x88, 0x38, 0x5C, 0x83, 0x2A, 0x28, 0x47, 0xDB, 0xB8, 0xC7, 0x93, 0xA4, 0x12, 0x53,
            0xFF, 0x87, 0x0E, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, 0x8E, 0x37, 0x74, 0x32, 0xCA, 0xE9, 0xB1,
            0xB7, 0xAB, 0x0C, 0xD7, 0xC4, 0x56, 0x42, 0x26, 0x07, 0x98, 0x60, 0xD9, 0xB6, 0xB9, 0x11, 0x40,
            0xEC, 0x20, 0x8C, 0xBD, 0xA0, 0xC9, 0x84, 0x04, 0x49, 0x23, 0xF1, 0x4F, 0x50, 0x1F, 0x13, 0xDC,
            0xD8, 0xC0, 0x9E, 0x57, 0xE3, 0xC3, 0x7B, 0x65, 0x3B, 0x02, 0x8F, 0x3E, 0xE8, 0x25, 0x92, 0xE5,
            0x15, 0xDD, 0xFD, 0x17, 0xA9, 0xBF, 0xD4, 0x9A, 0x7E, 0xC5, 0x39, 0x67, 0xFE, 0x76, 0x9D, 0x43,
            0xA7, 0xE1, 0xD0, 0xF5, 0x68, 0xF2, 0x1B, 0x34, 0x70, 0x05, 0xA3, 0x8A, 0xD5, 0x79, 0x86, 0xA8,
            0x30, 0xC6, 0x51, 0x4B, 0x1E, 0xA6, 0x27, 0xF6, 0x35, 0xD2, 0x6E, 0x24, 0x16, 0x82, 0x5F, 0xDA,
            0xE6, 0x75, 0xA2, 0xEF, 0x2C, 0xB2, 0x1C, 0x9F, 0x5D, 0x6F, 0x80, 0x0A, 0x72, 0x44, 0x9B, 0x6C,
            0x90, 0x0B, 0x5B, 0x33, 0x7D, 0x5A, 0x52, 0xF3, 0x61, 0xA1, 0xF7, 0xB0, 0xD6, 0x3F, 0x7C, 0x6D,
            0xED, 0x14, 0xE0, 0xA5, 0x3D, 0x22, 0xB3, 0xF8, 0x89, 0xDE, 0x71, 0x1A, 0xAF, 0xBA, 0xB5, 0x81
        };

        private static readonly byte[] S3 = new byte[]
        {
            0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
            0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
            0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
            0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
            0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
            0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
            0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
            0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
            0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
            0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
            0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
            0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
            0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
            0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
            0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
            0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
        };

        private static readonly byte[] S4 = new byte[]
        {
            0x30, 0x68, 0x99, 0x1B, 0x87, 0xB9, 0x21, 0x78, 0x50, 0x39, 0xDB, 0xE1, 0x72, 0x09, 0x62, 0x3C,
            0x3E, 0x7E, 0x5E, 0x8E, 0xF1, 0xA0, 0xCC, 0xA3, 0x2A, 0x1D, 0xFB, 0xB6, 0xD6, 0x20, 0xC4, 0x8D,
            0x81, 0x65, 0xF5, 0x89, 0xCB, 0x9D, 0x77, 0xC6, 0x57, 0x43, 0x56, 0x17, 0xD4, 0x40, 0x1A, 0x4D,
            0xC0, 0x63, 0x6C, 0xE3, 0xB7, 0xC8, 0x64, 0x6A, 0x53, 0xAA, 0x38, 0x98, 0x0C, 0xF4, 0x9B, 0xED,
            0x7F, 0x22, 0x76, 0xAF, 0xDD, 0x3A, 0x0B, 0x58, 0x67, 0x88, 0x06, 0xC3, 0x35, 0x0D, 0x01, 0x8B,
            0x8C, 0xC2, 0xE6, 0x5F, 0x02, 0x24, 0x75, 0x93, 0x66, 0x1E, 0xE5, 0xE2, 0x54, 0xD8, 0x10, 0xCE,
            0x7A, 0xE8, 0x08, 0x2C, 0x12, 0x97, 0x32, 0xAB, 0xB4, 0x27, 0x0A, 0x23, 0xDF, 0xEF, 0xCA, 0xD9,
            0xB8, 0xFA, 0xDC, 0x31, 0x6B, 0xD1, 0xAD, 0x19, 0x49, 0xBD, 0x51, 0x96, 0xEE, 0xE4, 0xA8, 0x41,
            0xDA, 0xFF, 0xCD, 0x55, 0x86, 0x36, 0xBE, 0x61, 0x52, 0xF8, 0xBB, 0x0E, 0x82, 0x48, 0x69, 0x9A,
            0xE0, 0x47, 0x9E, 0x5C, 0x04, 0x4B, 0x34, 0x15, 0x79, 0x26, 0xA7, 0xDE, 0x29, 0xAE, 0x92, 0xD7,
            0x84, 0xE9, 0xD2, 0xBA, 0x5D, 0xF3, 0xC5, 0xB0, 0xBF, 0xA4, 0x3B, 0x71, 0x44, 0x46, 0x2B, 0xFC,
            0xEB, 0x6F, 0xD5, 0xF6, 0x14, 0xFE, 0x7C, 0x70, 0x5A, 0x7D, 0xFD, 0x2F, 0x18, 0x83, 0x16, 0xA5,
            0x91, 0x1F, 0x05, 0x95, 0x74, 0xA9, 0xC1, 0x5B, 0x4A, 0x85, 0x6D, 0x13, 0x07, 0x4F, 0x4E, 0x45,
            0xB2, 0x0F, 0xC9, 0x1C, 0xA6, 0xBC, 0xEC, 0x73, 0x90, 0x7B, 0xCF, 0x59, 0x8F, 0xA1, 0xF9, 0x2D,
            0xF2, 0xB1, 0x00, 0x94, 0x37, 0x9F, 0xD0, 0x2E, 0x9C, 0x6E, 0x28, 0x3F, 0x80, 0xF0, 0x3D, 0xD3,
            0x25, 0x8A, 0xB5, 0xE7, 0x42, 0xB3, 0xC7, 0xEA, 0xF7, 0x4C, 0x11, 0x33, 0x03, 0xA2, 0xAC, 0x60
        };

        private static readonly byte[] C1 = new byte[]
        {
            0x51, 0x7C, 0xC1, 0xB7, 0x27, 0x22, 0x0A, 0x94, 0xFE, 0x13, 0xAB, 0xE8, 0xFA, 0x9A, 0x6E, 0xE0
        };

        private static readonly byte[] C2 = new byte[]
        {
            0x6D, 0xB1, 0x4A, 0xCC, 0x9E, 0x21, 0xC8, 0x20, 0xFF, 0x28, 0xB1, 0xD5, 0xEF, 0x5D, 0xE2, 0xB0
        };

        private static readonly byte[] C3 = new byte[]
        {
            0xDB, 0x92, 0x37, 0x1D, 0x21, 0x26, 0xE9, 0x70, 0x03, 0x24, 0x97, 0x75, 0x04, 0xE8, 0xC9, 0x0E
        };

        int Nk, Nr;

        public ARIA(int Nk, int Nr)
        {
            this.Nk = Nk;
            this.Nr = Nr;
        }

        private static void Fo(byte[] d, int dindex, byte[] rk, int rkindex)
        {
            for (int i = 0; i < 16; i++)
                d[dindex + i] ^= rk[rkindex + i];
            SL1(d, dindex);
            A(d, dindex);
        }

        private static void Fe(byte[] d, int dindex, byte[] rk, int rkindex)
        {
            for (int i = 0; i < 16; i++)
                d[dindex + i] ^= rk[rkindex + i];
            SL2(d, dindex);
            A(d, dindex);
        }

        private static void SL1(byte[] x, int index)
        {
            x[index +  0] = S1[x[index +  0]];
            x[index +  1] = S2[x[index +  1]];
            x[index +  2] = S3[x[index +  2]];
            x[index +  3] = S4[x[index +  3]];
            x[index +  4] = S1[x[index +  4]];
            x[index +  5] = S2[x[index +  5]];
            x[index +  6] = S3[x[index +  6]];
            x[index +  7] = S4[x[index +  7]];
            x[index +  8] = S1[x[index +  8]];
            x[index +  9] = S2[x[index +  9]];
            x[index + 10] = S3[x[index + 10]];
            x[index + 11] = S4[x[index + 11]];
            x[index + 12] = S1[x[index + 12]];
            x[index + 13] = S2[x[index + 13]];
            x[index + 14] = S3[x[index + 14]];
            x[index + 15] = S4[x[index + 15]];
        }

        private static void SL2(byte[] x, int index)
        {
            x[index +  0] = S3[x[index +  0]];
            x[index +  1] = S4[x[index +  1]];
            x[index +  2] = S1[x[index +  2]];
            x[index +  3] = S2[x[index +  3]];
            x[index +  4] = S3[x[index +  4]];
            x[index +  5] = S4[x[index +  5]];
            x[index +  6] = S1[x[index +  6]];
            x[index +  7] = S2[x[index +  7]];
            x[index +  8] = S3[x[index +  8]];
            x[index +  9] = S4[x[index +  9]];
            x[index + 10] = S1[x[index + 10]];
            x[index + 11] = S2[x[index + 11]];
            x[index + 12] = S3[x[index + 12]];
            x[index + 13] = S4[x[index + 13]];
            x[index + 14] = S1[x[index + 14]];
            x[index + 15] = S2[x[index + 15]];
        }

        private static byte[] KeyExpansion(byte[] key, byte[] ck1, byte[] ck2, byte[] ck3, int rounds)
        {
            byte[] k = new byte[32];
            Array.Copy(key, k, key.Length);

            byte[] w = new byte[64];

            // W0 = KL
            Array.Copy(k, w, 16);

            // W1 = FO(W0, CK1) ^ KR
            Array.Copy(w, 0, w, 16, 16);
            Fo(w, 16, ck1, 0);
            for (int i = 0; i < 16; i++)
                w[16 + i] ^= k[16 + i];

            // W2 = FE(W1, CK2) ^ W0
            Array.Copy(w, 16, w, 32, 16);
            Fe(w, 32, ck2, 0);
            for (int i = 0; i < 16; i++)
                w[32 + i] ^= w[i];

            // W3 = FO(W2, CK3) ^ W1
            Array.Copy(w, 32, w, 48, 16);
            Fo(w, 48, ck3, 0);
            for (int i = 0; i < 16; i++)
                w[48 + i] ^= w[16 + i];

            byte[] ek = new byte[rounds * 16 + 16];

            // ek1  = W0 ^(W1 >>> 19)
            Array.Copy(w, 0, ek, 0, 16);
            BitHelper.RotateRight128AndXor(ek, 0, w, 16, 19);

            // ek2 = W1 ^ (W2 >>> 19)
            Array.Copy(w, 16, ek, 16, 16);
            BitHelper.RotateRight128AndXor(ek, 16, w, 32, 19);

            // ek3 = W2 ^ (W3 >>> 19)
            Array.Copy(w, 32, ek, 32, 16);
            BitHelper.RotateRight128AndXor(ek, 32, w, 48, 19);

            // ek4 = W3 ^ (W0 >>> 19)
            Array.Copy(w, 48, ek, 48, 16);
            BitHelper.RotateRight128AndXor(ek, 48, w, 0, 19);

            // ek5 = W0 ^ (W1 >>> 31)
            Array.Copy(w, 0, ek, 64, 16);
            BitHelper.RotateRight128AndXor(ek, 64, w, 16, 31);

            // ek6 = W1 ^ (W2 >>> 31)
            Array.Copy(w, 16, ek, 80, 16);
            BitHelper.RotateRight128AndXor(ek, 80, w, 32, 31);

            // ek7 = W2 ^ (W3 >>> 31)
            Array.Copy(w, 32, ek, 96, 16);
            BitHelper.RotateRight128AndXor(ek, 96, w, 48, 31);

            // ek8 = W3 ^ (W0 >>> 31)
            Array.Copy(w, 48, ek, 112, 16);
            BitHelper.RotateRight128AndXor(ek, 112, w, 0, 31);

            // ek9 = W0 ^ (W1 <<< 61)
            Array.Copy(w, 0, ek, 128, 16);
            BitHelper.RotateLeft128AndXor(ek, 128, w, 16, 61);

            // ek10 = W1 ^ (W2 <<< 61)
            Array.Copy(w, 16, ek, 144, 16);
            BitHelper.RotateLeft128AndXor(ek, 144, w, 32, 61);

            // ek11 = W2 ^ (W3 <<< 61)
            Array.Copy(w, 32, ek, 160, 16);
            BitHelper.RotateLeft128AndXor(ek, 160, w, 48, 61);

            // ek12 = W3 ^ (W0 <<< 61)
            Array.Copy(w, 48, ek, 176, 16);
            BitHelper.RotateLeft128AndXor(ek, 176, w, 0, 61);

            // ek13 = W0 ^ (W1 <<< 31)
            Array.Copy(w, 0, ek, 192, 16);
            BitHelper.RotateLeft128AndXor(ek, 192, w, 16, 31);

            if (rounds > 12)
            {
                // ek14 = W1 ^ (W2 <<< 31)
                Array.Copy(w, 16, ek, 208, 16);
                BitHelper.RotateLeft128AndXor(ek, 208, w, 32, 31);

                // ek15 = W2 ^ (W3 <<< 31)
                Array.Copy(w, 32, ek, 224, 16);
                BitHelper.RotateLeft128AndXor(ek, 224, w, 48, 31);

                if (rounds > 14)
                {
                    // ek16 = W3 ^ (W0 <<< 31)
                    Array.Copy(w, 48, ek, 240, 16);
                    BitHelper.RotateLeft128AndXor(ek, 240, w, 0, 31);

                    // ek17 = W0 ^ (W1 <<< 19)
                    Array.Copy(w, 0, ek, 256, 16);
                    BitHelper.RotateLeft128AndXor(ek, 256, w, 16, 19);
                }
            }

            return ek;
        }

        private static byte[] ConvertKeys(byte[] ek)
        {
            int len = ek.Length;
            byte[] dk = new byte[len];

            Array.Copy(ek, len - 16, dk, 0, 16);
            for (int i = 1; i < len / 16 - 1; i++)
            {
                Array.Copy(ek, len - (i + 1) * 16, dk, i * 16, 16);
                A(dk, i * 16);
            }
            Array.Copy(ek, 0, dk, len - 16, 16);

            return dk;
        }

        private static void A(byte[] x, int i)
        {
            byte y0 =  (byte)(x[i + 3] ^ x[i + 4] ^ x[i + 6] ^ x[i +  8] ^ x[i +  9] ^ x[i + 13] ^ x[i + 14]);
            byte y1 =  (byte)(x[i + 2] ^ x[i + 5] ^ x[i + 7] ^ x[i +  8] ^ x[i +  9] ^ x[i + 12] ^ x[i + 15]);
            byte y2 =  (byte)(x[i + 1] ^ x[i + 4] ^ x[i + 6] ^ x[i + 10] ^ x[i + 11] ^ x[i + 12] ^ x[i + 15]);
            byte y3 =  (byte)(x[i + 0] ^ x[i + 5] ^ x[i + 7] ^ x[i + 10] ^ x[i + 11] ^ x[i + 13] ^ x[i + 14]);
            byte y4 =  (byte)(x[i + 0] ^ x[i + 2] ^ x[i + 5] ^ x[i +  8] ^ x[i + 11] ^ x[i + 14] ^ x[i + 15]);
            byte y5 =  (byte)(x[i + 1] ^ x[i + 3] ^ x[i + 4] ^ x[i +  9] ^ x[i + 10] ^ x[i + 14] ^ x[i + 15]);
            byte y6 =  (byte)(x[i + 0] ^ x[i + 2] ^ x[i + 7] ^ x[i +  9] ^ x[i + 10] ^ x[i + 12] ^ x[i + 13]);
            byte y7 =  (byte)(x[i + 1] ^ x[i + 3] ^ x[i + 6] ^ x[i +  8] ^ x[i + 11] ^ x[i + 12] ^ x[i + 13]);
            byte y8 =  (byte)(x[i + 0] ^ x[i + 1] ^ x[i + 4] ^ x[i +  7] ^ x[i + 10] ^ x[i + 13] ^ x[i + 15]);
            byte y9 =  (byte)(x[i + 0] ^ x[i + 1] ^ x[i + 5] ^ x[i +  6] ^ x[i + 11] ^ x[i + 12] ^ x[i + 14]);
            byte y10 = (byte)(x[i + 2] ^ x[i + 3] ^ x[i + 5] ^ x[i +  6] ^ x[i +  8] ^ x[i + 13] ^ x[i + 15]);
            byte y11 = (byte)(x[i + 2] ^ x[i + 3] ^ x[i + 4] ^ x[i +  7] ^ x[i +  9] ^ x[i + 12] ^ x[i + 14]);
            byte y12 = (byte)(x[i + 1] ^ x[i + 2] ^ x[i + 6] ^ x[i +  7] ^ x[i +  9] ^ x[i + 11] ^ x[i + 12]);
            byte y13 = (byte)(x[i + 0] ^ x[i + 3] ^ x[i + 6] ^ x[i +  7] ^ x[i +  8] ^ x[i + 10] ^ x[i + 13]);
            byte y14 = (byte)(x[i + 0] ^ x[i + 3] ^ x[i + 4] ^ x[i +  5] ^ x[i +  9] ^ x[i + 11] ^ x[i + 14]);
            byte y15 = (byte)(x[i + 1] ^ x[i + 2] ^ x[i + 4] ^ x[i +  5] ^ x[i +  8] ^ x[i + 10] ^ x[i + 15]);

            x[i + 0] = y0;
            x[i + 1] = y1;
            x[i + 2] = y2;
            x[i + 3] = y3;
            x[i + 4] = y4;
            x[i + 5] = y5;
            x[i + 6] = y6;
            x[i + 7] = y7;
            x[i + 8] = y8;
            x[i + 9] = y9;
            x[i + 10] = y10;
            x[i + 11] = y11;
            x[i + 12] = y12;
            x[i + 13] = y13;
            x[i + 14] = y14;
            x[i + 15] = y15;
        }

        public override Encryptor CreateEncryptor(byte[] key, BlockCipherMode mode)
        {
            byte[] ek;
            switch (Nk)
            {
                case 128: ek = KeyExpansion(key, C1, C2, C3, Nr); break;
                case 192: ek = KeyExpansion(key, C2, C3, C1, Nr); break;
                case 256: ek = KeyExpansion(key, C3, C1, C2, Nr); break;
                default:
                    throw new NotImplementedException();
            }

            var encryptor = ResolveEncryptor(mode);
            encryptor.Cipher = this;
            encryptor.ProcessBlock = ProcessBlock(ek, Nr);

            return encryptor;
        }

        public override Decryptor CreateDecryptor(byte[] key, BlockCipherMode mode)
        {
            byte[] ek;
            switch (Nk)
            {
                case 128: ek = KeyExpansion(key, C1, C2, C3, Nr); break;
                case 192: ek = KeyExpansion(key, C2, C3, C1, Nr); break;
                case 256: ek = KeyExpansion(key, C3, C1, C2, Nr); break;
                default:
                    throw new NotImplementedException();
            }
            byte[] dk = ConvertKeys(ek);

            var decryptor = ResolveDecryptor(mode);
            decryptor.Cipher = this;
            decryptor.ProcessBlock = ProcessBlock(dk, Nr);

            return decryptor;
        }

        private static Func<byte[], byte[]> ProcessBlock(byte[] ek, int Nr)
        {
            return (block) =>
            {
                byte[] p = new byte[16];
                Array.Copy(block, p, 16);

                int lastRoundIndex;

                Fo(p, 0, ek, 0);   // Round 1
                Fe(p, 0, ek, 16);  // Round 2
                Fo(p, 0, ek, 32);  // Round 3
                Fe(p, 0, ek, 48);  // Round 4
                Fo(p, 0, ek, 64);  // Round 5
                Fe(p, 0, ek, 80);  // Round 6
                Fo(p, 0, ek, 96);  // Round 7
                Fe(p, 0, ek, 112); // Round 8
                Fo(p, 0, ek, 128); // Round 9
                Fe(p, 0, ek, 144); // Round 10
                Fo(p, 0, ek, 160); // Round 11
                if (Nr > 12)
                {
                    Fe(p, 0, ek, 176); // Round 12
                    Fo(p, 0, ek, 192); // Round 13
                    if (Nr > 14)
                    {
                        Fe(p, 0, ek, 208); // Round 14
                        Fo(p, 0, ek, 224); // Round 15
                        lastRoundIndex = 240; // 256-bit key
                    }
                    else
                        lastRoundIndex = 208; // 192-bit key
                }
                else
                    lastRoundIndex = 176; // 128-bit key

                for (int i = 0; i < 16; i++)
                    p[i] ^= ek[lastRoundIndex + i];
                SL2(p, 0);
                for (int i = 0; i < 16; i++)
                    p[i] ^= ek[lastRoundIndex + 16 + i];

                return p;
            };
        }
    }
}